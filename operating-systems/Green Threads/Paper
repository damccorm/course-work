Team Members: Daniel McCormick and Carl Block
VUNet ID’s: mccord1 and 
Project Repository: https://github.com/CS3281-2016/Danny-Carl-Project

Green Threads:

Implementation Details:
	To implement green threads, we used the basic shell provided at http://c9x.me/art/gthreads/code0.html and extended it to include a scheduling policy and priority. The final product consisted of two files. The first had defined structures to hold green threads and their properties, a function to initialize a green thread pool, a function to terminate threads (along with a small helper function), a function to switch in a new thread, a function to initialize threads, and some test code. The second file had code to context switch green threads in and out. The actual threads are structs that have variables to hold their context, running state, order in their respective queue (though a queue structure is not formally used), and the length of time that they have been running. They are held in an array that contains all the threads in the thread pool. Overall, the program follows the following sequence: a thread pool is initialized, several threads are initialized, and then they are allowed to run until completion while switching in and out based on their priority and a chosen scheduling policy. We limited the policies to SCHED_FIFO and SCHED_RR for simplicity’s sake.
	The first function called by main is gtinit which initializes the thread pool. It does so by initializing the first “bootstrap” thread. This thread is given a priority of 0 so that it only runs before and after all the other threads have run. It essentially represents the main context.
	The next function called by main is gtgo which creates all of the other threads. It takes in a priority which must be between 1 and 99, a policy, and a function to run when it is scheduled in. The thread is created by allocating memory on the stack, giving it a new and original context, and setting its priority, policy, and order. If anything fails, it returns -1 immediately. There are several noteworthy things that happen in this step. First of all, when the context is set, it allocates specific parts of the stack to correspond to the function that was passed in and this particular thread’s gtstop function. This essentially ties instances of the functions to this thread and allows several different instances of the function to exist within the program, each tied to a different context but all residing in the same relative location in their part of the stack. In particular, gtstop is tied to the thread such that when the thread is done executing, gtstop gets called. The next noteworthy thing that happens in this step is that the priority is set for each individual thread but the policy is set for all of the threads. This is done to avoid different threads having conflicting policies. Finally, the order is set to the maximum number of threads. This is the highest order supported by this implementation and essentially sends it to the back of its priority queue. Because we don’t use an actual queue and we just store the threads in an array, we use the order variable to put the threads in order in which they were last added or run
	The last function called by main is gtret, which is a function designed to kill threads when they are done. Basically, it sets the thread’s running state to unused, lowers its priority so that the next highest priority gets called, and yields to another thread. The first time it is called, however, it is called on the bootstrap thread so it just yields until all the other threads are done. When they are all finished, it returns to main. Of particular note is that gtret has a helper function, gtstop, which just calls gtret for the current thread. As mentioned above, each thread’s context has an instance of gtstop in its context, so this allows different instances of gtret as well which will be called when the function is done running.
	Finally, gtyield is the function used for threads to yield control to another thread. It is called both by gtret when the thread is done as well as by f, the function running inside each thread. The major distinction here is that when it is called from f, it maintains the thread’s original priority and running state and can thus be called again. When gtyield is called by gtret, however, the thread will never be called again. This function is also responsible for doing most of the work of implementing scheduling policy and priority. It does this at the start of the function. If it is using SCHED_FIFO, it simply sets the order of the current thread to the max value, putting it at the back of its priority queue. If it is using SCHED_RR, it only does that if the current thread has not used its entire time slice. The amount of time used is calculated by storing the time at the end of gtyield (when a new thread starts) and subtracting it from the time at the start of gtyield (when that thread ends). If the thread has not used its entire time slice, its order is decremented by one to keep it at the front of the queue. 
After the scheduling policies have been thus implemented, the function moves on to selecting the next thread to run. It does so by storing the current thread, its priority, and its order in temporary variables. Next, it loops through all of the threads looking for one that is ready to execute. When it finds one that is ready, it compares its priority to the temporary variable. If it is greater, then it makes that thread the new temporary thread and sets the temporary priority and order variables to that thread’s priority and order. If it is equal to the temporary priority, it compares orders and makes the thread with the lower order the new temporary thread. Otherwise, it moves on to the next thread. Once it has looped through all of the threads, it context switches in the temporary thread. If the temporary thread is gtcur, this just means restarting the timer and returning false. Otherwise, it means setting all of the appropriate variables to new values, calling gtswtch, and returning true.
In gtswtch (another file), all of the context variables from the new thread are swapped into gtcur, which holds our currently running thread. It then returns to the function that called it. Of particular note, is that when the context is switched, the function associated with the current thread’s context is switched so that it is now the instance associated with the thread that we are swapping in.
